# Evaluation Part I 評估第一部分
(續)
使用 LLM 建立應用程式:
==使用者輸入 → 評估輸入 → 處理輸入 → 模型生成輸出 → 檢查/評估輸出 → 實際輸出==

當你建立這樣的系統之後，當部署並讓使用者使用時:
* 如何知道它運作的情況如何？
* 如何追蹤它的表現？
* 如何找出任何不足之處並持續提升系統的回答品質？

---

## 應用程式建立流程
### 監督式學習 vs 基於提示的 AI
* 傳統(監督式)機器學習
  一開始就需收集大量訓練/測試資料集。
    1. 取得標記數據 (1個月)
    2. 根據資料訓練模型 (3個月)
    3. 部署和呼叫模型 (3個月)
* 基於提示的 AI
  開發速度快，初期不需完整的測試集，透過逐步添加範例建立評估集。
    1. 指定提示 (分鐘/小時)
    2. 呼叫模型 (分鐘/小時)

### 建立流程
==少量範例 → 微調和優化系統提示 → 蒐集棘手範例(加到開發集) → 微調和優化系統提示 → 進行測試(測試集) → 微調和優化系統提示 → 需提高正確率/遇到棘手範例 → ...==
形成一個持續改進的循環，有助於提升系統的準確性與穩定性。

1. 根據少量範例調整提示
    * 初版提示
    * 從 1～3 個 prompt 開始（few-shot prompting）
    * 針對這些範例調整 prompt，直到產出正確輸出
2. 適時添加額外的“棘手”示例
    * 查看運行情況，每當遇到錯誤/奇怪輸出，將該例加入到開發集中。
    * 這些是「困難但具有代表性」的實例，請持續擴充並觀察提示的適應性。
3. 制定衡量範例績效的指標
    * 準確度：系統返回正確答案的百分比。
    * 回歸測試：在修改提示後，重新運行之前的測試範例，確保改動沒有引入新的錯誤。
    * 特殊情況：關注那些系統經常出錯的範例，通過修復這些錯誤，提升系統的整體表現。

### 進階流程
保留測試集擴大，量化評估指標，並進行自動化測試。可以快速發現問題、持續調整模型，進而達到最佳效果。

4. 自動化測試
    * 當範例數累積超過 5～10 筆後，可以開始使用指標（如準確率）進行自動化評估，同時進行回歸測試（確認修 prompt 後沒破壞先前表現）。如果分數不理想，則重新進行微調。
    * 回歸測試: 
      修改提示後重新測試所有範例
        * 確保舊的正確例子仍正確（無破壞）
        * 確保新的錯誤例子被修復
5. 收集隨機抽樣的範例集進行調整
   （開發集/保留交叉驗證集）
   （Development Set / Hold-out Cross Validation Set）
    * 需要更高精度的性能估算時，才會收集並使用一個完全未接觸過的測試集。
      (如，正確率希望從 91% 調整到更高時)
    * 若手動建立的測試集不足以建立信心，可收集隨機樣本進行測試。
6. 收集並使用保留測試集 (Hold-out Test Set)
    * **不需要**使用嚴格測試集:
        * 低風險任務（如內部摘要、文章閱讀）
        * 正確率大約在 80–90% 就能接受
    * **需要**使用嚴格測試集
        * 需要無偏、公正的估算系統表現時
        * 高風險任務（如醫療、金融）
        * 錯誤可能導致實質損害
    * 對於任何高風險應用，應避免偏見或不適當的輸出，防止對別人造成傷害。

| 項目 | Development Set / Validation Set | Hold-out Test Set |
| -------- | -------- | -------- |
| 功能 | 用於模型調整、驗證與選擇 | 用於最終模型效能評估 |
| 使用時機 | 模型訓練與開發過程中 | 模型訓練完成後 |
| 是否參與訓練調整 | 是 | 否 |
| 數據來源 | 訓練資料中劃分而來 | 通常從一開始就與訓練資料分離 |

### 實務建議
* 對於大多數非關鍵應用（如個人文章摘要），風險比較小，可以不用進行深入測試，來收集更大的數據集來評估你的算法。
* 對於高風險場景（如醫療、法律等），請進行深入測試，它需要更嚴格的測試標準與更大量的數據(擴大測試集)，以及完善評估流程，來確保系統的可靠性與安全性，保證在各種情況下都不會出現重大錯誤。
* 評估的方法通常不會一開始就用測試集。相反，你往往會逐步建立測試範例的集合。
* 關注那些系統經常出錯的範例，通過修復這些錯誤，提升系統的整體表現。

---

## 補充
### 樣本提示指令
* 零樣本提示（Zero-Shot）
    * 使模型能夠在無先前範例下提供回答
* 一次性樣本提示（One-Shot）
    * 利用單一範例來提升回答品質
* 少量樣本提示（Few-Shot）
    * 透過提供一個以上的範例指示LLM模型，來解決更複雜問題。
* [參考來源](https://medium.com/seaniap/chatgpt%E4%B9%8B%E6%A8%A3%E6%9C%AC%E6%8F%90%E7%A4%BA%E6%8C%87%E4%BB%A4-zero-shot-one-shot-%E8%88%87few-shot-c5d3b91b02c4)

---

## 實作範例

### 取得相關產品和類別
使用 utils 函數來獲取產品和類別的清單。
```python
products_and_category = utils.get_products_and_category()
products_and_category
```

### 尋找相關的產品和類別名稱（版本 1）
提示中規定了一些指示，並實際給出了一個良好輸出的例子，這通常被稱為「One-Shot」或「Few-Shot」樣本提示。

實際上使用了一條使用者訊息和一條系統訊息，來給它一個良好的輸出示範。
```python
def find_category_and_product_v1(user_input,products_and_category):

    delimiter = "####"
    system_message = f"""
    You will be provided with customer service queries. \
    The customer service query will be delimited with {delimiter} characters.
    Output a python list of json objects, where each object has the following format:
        'category': <one of Computers and Laptops, Smartphones and Accessories, Televisions and Home Theater Systems, \
    Gaming Consoles and Accessories, Audio Equipment, Cameras and Camcorders>,
    AND
        'products': <a list of products that must be found in the allowed products below>


    Where the categories and products must be found in the customer service query.
    If a product is mentioned, it must be associated with the correct category in the allowed products list below.
    If no products or categories are found, output an empty list.
    

    List out all products that are relevant to the customer service query based on how closely it relates
    to the product name and product category.
    Do not assume, from the name of the product, any features or attributes such as relative quality or price.

    The allowed products are provided in JSON format.
    The keys of each item represent the category.
    The values of each item is a list of products that are within that category.
    Allowed products: {products_and_category}
    

    """
    
    few_shot_user_1 = """I want the most expensive computer."""
    few_shot_assistant_1 = """ 
    [{'category': 'Computers and Laptops', \
'products': ['TechPro Ultrabook', 'BlueWave Gaming Laptop', 'PowerLite Convertible', 'TechPro Desktop', 'BlueWave Chromebook']}]
    """
    
    messages =  [  
    {'role':'system', 'content': system_message},    
    {'role':'user', 'content': f"{delimiter}{few_shot_user_1}{delimiter}"},  
    {'role':'assistant', 'content': few_shot_assistant_1 },
    {'role':'user', 'content': f"{delimiter}{user_input}{delimiter}"},  
    ] 
    return get_completion_from_messages(messages)
```

### 對一些查詢進行評估
將這個提示、使用者訊息以及產品和類別資訊傳入輔助函式，來檢索相關的類別和產品。
```python
# 「我有預算，我可以買什麼電視？」
customer_msg_0 = f"""Which TV can I buy if I'm on a budget?"""

products_by_category_0 = find_category_and_product_v1(customer_msg_0,
                                                      products_and_category)
print(products_by_category_0)
```
```python
# 「我需要一個智慧型手機充電器。」
customer_msg_1 = f"""I need a charger for my smartphone"""

products_by_category_1 = find_category_and_product_v1(customer_msg_1,
                                                      products_and_category)
print(products_by_category_1)
```
```python
# 「你有什麼電腦？」
customer_msg_2 = f"""
What computers do you have?"""

products_by_category_2 = find_category_and_product_v1(customer_msg_2,
                                                      products_and_category)
products_by_category_2
```

### 更難的測試案例
遇到提示系統無法處理的情況。
(如，預期產生JSON就好，但出現多餘的文字訊息，導致難以將其轉換成 Python 字典列表。)
```python
# 「告訴我有關 SmartX Pro 手機和 Fotosnap 相機的信息。另外，你有什麼電視？」
customer_msg_3 = f"""
tell me about the smartx pro phone and the fotosnap camera, the dslr one.
Also, what TVs do you have?"""

products_by_category_3 = find_category_and_product_v1(customer_msg_3,
                                                      products_and_category)
print(products_by_category_3)
```

常見做法: 
將這個範例標記為一個比較棘手的例子，並將它添加到我們測試系統的範例集中，修改完提示，然後再進行系統測試。
```python
customer_msg_4 = f"""
tell me about the CineView TV, the 8K one, Gamesphere console, the X one.
I'm on a budget, what computers do you have?"""

products_by_category_4 = find_category_and_product_v1(customer_msg_4,
                                                      products_and_category)
print(products_by_category_4)
```

### 修改提示以處理困難的測試案例 （版本2）
將微調提示，並且加入了少量範例來加強。
（「Few-Shot」樣本提示）
```python
# 「添加: 請不要輸出任何非JSON格式的附加文本」
def find_category_and_product_v2(user_input,products_and_category):
    """
    Added: Do not output any additional text that is not in JSON format.
    Added a second example (for few-shot prompting) where user asks for 
    the cheapest computer. In both few-shot examples, the shown response 
    is the full list of products in JSON only.
    """
    delimiter = "####"
    system_message = f"""
    You will be provided with customer service queries. \
    The customer service query will be delimited with {delimiter} characters.
    Output a python list of json objects, where each object has the following format:
        'category': <one of Computers and Laptops, Smartphones and Accessories, Televisions and Home Theater Systems, \
    Gaming Consoles and Accessories, Audio Equipment, Cameras and Camcorders>,
    AND
        'products': <a list of products that must be found in the allowed products below>
    Do not output any additional text that is not in JSON format.
    Do not write any explanatory text after outputting the requested JSON.


    Where the categories and products must be found in the customer service query.
    If a product is mentioned, it must be associated with the correct category in the allowed products list below.
    If no products or categories are found, output an empty list.
    

    List out all products that are relevant to the customer service query based on how closely it relates
    to the product name and product category.
    Do not assume, from the name of the product, any features or attributes such as relative quality or price.

    The allowed products are provided in JSON format.
    The keys of each item represent the category.
    The values of each item is a list of products that are within that category.
    Allowed products: {products_and_category}
    

    """
    
    few_shot_user_1 = """I want the most expensive computer. What do you recommend?"""
    few_shot_assistant_1 = """ 
    [{'category': 'Computers and Laptops', \
'products': ['TechPro Ultrabook', 'BlueWave Gaming Laptop', 'PowerLite Convertible', 'TechPro Desktop', 'BlueWave Chromebook']}]
    """
    
    few_shot_user_2 = """I want the most cheapest computer. What do you recommend?"""
    few_shot_assistant_2 = """ 
    [{'category': 'Computers and Laptops', \
'products': ['TechPro Ultrabook', 'BlueWave Gaming Laptop', 'PowerLite Convertible', 'TechPro Desktop', 'BlueWave Chromebook']}]
    """
    
    messages =  [  
    {'role':'system', 'content': system_message},    
    {'role':'user', 'content': f"{delimiter}{few_shot_user_1}{delimiter}"},  
    {'role':'assistant', 'content': few_shot_assistant_1 },
    {'role':'user', 'content': f"{delimiter}{few_shot_user_2}{delimiter}"},  
    {'role':'assistant', 'content': few_shot_assistant_2 },
    {'role':'user', 'content': f"{delimiter}{user_input}{delimiter}"},  
    ] 
    return get_completion_from_messages(messages)
```

### 在困難測試案例上評估修改後的提示
調整過的提示（v2）可以在運行時，能夠返回我們所期望的結果。
```python
customer_msg_3 = f"""
tell me about the smartx pro phone and the fotosnap camera, the dslr one.
Also, what TVs do you have?"""

products_by_category_3 = find_category_and_product_v2(customer_msg_3, products_and_category)
print(products_by_category_3)
```

### 迴歸測試：驗證模型在先前的測試案例上仍然有效
檢查調整過的提示會不會對其在先前測試案例上的效能產生負面影響。特別是那些原本運作正常的範例，透過測試可以確保修改後系統不會重蹈覆轍。
```python
customer_msg_0 = f"""Which TV can I buy if I'm on a budget?"""

products_by_category_0 = find_category_and_product_v2(customer_msg_0, products_and_category)
print(products_by_category_0)
```

### 收集自動化測試的開發套件
列出**使用者請求**與**理想回答**的對應清單。
* 理想回答: 正確的答案或預期的輸出。
```python
msg_ideal_pairs_set = [
    
    # eg 0
    {'customer_msg':"""Which TV can I buy if I'm on a budget?""",
     'ideal_answer':{
        'Televisions and Home Theater Systems':set(
            ['CineView 4K TV', 'SoundMax Home Theater', 'CineView 8K TV', 'SoundMax Soundbar', 'CineView OLED TV']
        )}
    },

    # eg 1
    {'customer_msg':"""I need a charger for my smartphone""",
     'ideal_answer':{
        'Smartphones and Accessories':set(
            ['MobiTech PowerCase', 'MobiTech Wireless Charger', 'SmartX EarBuds']
        )}
    },
    # eg 2
    {'customer_msg':f"""What computers do you have?""",
     'ideal_answer':{
           'Computers and Laptops':set(
               ['TechPro Ultrabook', 'BlueWave Gaming Laptop', 'PowerLite Convertible', 'TechPro Desktop', 'BlueWave Chromebook'
               ])
                }
    },

    # eg 3
    {'customer_msg':f"""tell me about the smartx pro phone and \
    the fotosnap camera, the dslr one.\
    Also, what TVs do you have?""",
     'ideal_answer':{
        'Smartphones and Accessories':set(
            ['SmartX ProPhone']),
        'Cameras and Camcorders':set(
            ['FotoSnap DSLR Camera']),
        'Televisions and Home Theater Systems':set(
            ['CineView 4K TV', 'SoundMax Home Theater','CineView 8K TV', 'SoundMax Soundbar', 'CineView OLED TV'])
        }
    }, 
    
    # eg 4
    {'customer_msg':"""tell me about the CineView TV, the 8K one, Gamesphere console, the X one.
I'm on a budget, what computers do you have?""",
     'ideal_answer':{
        'Televisions and Home Theater Systems':set(
            ['CineView 8K TV']),
        'Gaming Consoles and Accessories':set(
            ['GameSphere X']),
        'Computers and Laptops':set(
            ['TechPro Ultrabook', 'BlueWave Gaming Laptop', 'PowerLite Convertible', 'TechPro Desktop', 'BlueWave Chromebook'])
        }
    },
    
    # eg 5
    {'customer_msg':f"""What smartphones do you have?""",
     'ideal_answer':{
           'Smartphones and Accessories':set(
               ['SmartX ProPhone', 'MobiTech PowerCase', 'SmartX MiniPhone', 'MobiTech Wireless Charger', 'SmartX EarBuds'
               ])
                    }
    },
    # eg 6
    {'customer_msg':f"""I'm on a budget.  Can you recommend some smartphones to me?""",
     'ideal_answer':{
        'Smartphones and Accessories':set(
            ['SmartX EarBuds', 'SmartX MiniPhone', 'MobiTech PowerCase', 'SmartX ProPhone', 'MobiTech Wireless Charger']
        )}
    },

    # eg 7 # this will output a subset of the ideal answer
    {'customer_msg':f"""What Gaming consoles would be good for my friend who is into racing games?""",
     'ideal_answer':{
        'Gaming Consoles and Accessories':set([
            'GameSphere X',
            'ProGamer Controller',
            'GameSphere Y',
            'ProGamer Racing Wheel',
            'GameSphere VR Headset'
     ])}
    },
    # eg 8
    {'customer_msg':f"""What could be a good present for my videographer friend?""",
     'ideal_answer': {
        'Cameras and Camcorders':set([
        'FotoSnap DSLR Camera', 'ActionCam 4K', 'FotoSnap Mirrorless Camera', 'ZoomMaster Camcorder', 'FotoSnap Instant Camera'
        ])}
    },
    
    # eg 9 (沒有相關的產品，所以理想答案是空集)
    {'customer_msg':f"""I would like a hot tub time machine.""",
     'ideal_answer': []
    }
    
]
```

### 透過與理想答案進行比較來評估測試案例
制定衡量範例績效的指標

測試函數: 自動化測試，用來輸入客戶訊息和理想答案，並比對系統回應是否一致，可以輕鬆地查看它的準確度。

假如模型回應正確，則可以給它一個得分，反之則指出錯誤。
```python
import json
def eval_response_with_ideal(response,
                              ideal,
                              debug=False):
    
    if debug:
        print("response")
        print(response)
    
    # json.loads() expects double quotes, not single quotes
    json_like_str = response.replace("'",'"')
    
    # parse into a list of dictionaries
    l_of_d = json.loads(json_like_str)
    
    # special case when response is empty list
    if l_of_d == [] and ideal == []:
        return 1
    
    # otherwise, response is empty 
    # or ideal should be empty, there's a mismatch
    elif l_of_d == [] or ideal == []:
        return 0
    
    correct = 0    
    
    if debug:
        print("l_of_d is")
        print(l_of_d)
    for d in l_of_d:

        cat = d.get('category')
        prod_l = d.get('products')
        if cat and prod_l:
            # convert list to set for comparison
            prod_set = set(prod_l)
            # get ideal set of products
            ideal_cat = ideal.get(cat)
            if ideal_cat:
                prod_set_ideal = set(ideal.get(cat))
            else:
                if debug:
                    print(f"did not find category {cat} in ideal")
                    print(f"ideal: {ideal}")
                continue
                
            if debug:
                print("prod_set\n",prod_set)
                print()
                print("prod_set_ideal\n",prod_set_ideal)

            if prod_set == prod_set_ideal:
                if debug:
                    print("correct")
                correct +=1
            else:
                print("incorrect")
                print(f"prod_set: {prod_set}")
                print(f"prod_set_ideal: {prod_set_ideal}")
                if prod_set <= prod_set_ideal:
                    print("response is a subset of the ideal answer")
                elif prod_set >= prod_set_ideal:
                    print("response is a superset of the ideal answer")

    # count correct over total number of items in list
    pc_correct = correct / len(l_of_d)
        
    return pc_correct
```
使用者輸入 & 理想答案
```python
print(f'Customer message: {msg_ideal_pairs_set[7]["customer_msg"]}')
print(f'Ideal answer: {msg_ideal_pairs_set[7]["ideal_answer"]}')
```
系統回應 (如果回應完全符合預期，它將給出1.0的分數)
```python
response = find_category_and_product_v2(msg_ideal_pairs_set[7]["customer_msg"], products_and_category)
print(f'Resonse: {response}')

eval_response_with_ideal(response, msg_ideal_pairs_set[7]["ideal_answer"])
```

### 對所有測試案例進行評估，並計算正確用例的比例
執行所有範例測試系統，有助於識別系統中表現優異的部分及需改進之處，並清楚掌握系統的強項與弱點。

計算平均正確率來評估整體效能:
例如，若正確率達到 90%，表示系統整體表現不錯。當你進一步調整提示並重新測試時，就能判斷這些修改是否實際提升了準確率，或是否引入了新問題。
```python
# Note, this will not work if any of the api calls time out
score_accum = 0
for i, pair in enumerate(msg_ideal_pairs_set):
    print(f"example {i}")
    
    customer_msg = pair['customer_msg']
    ideal = pair['ideal_answer']
    
    # print("Customer message",customer_msg)
    # print("ideal:",ideal)
    response = find_category_and_product_v2(customer_msg, products_and_category)

    
    # print("products_by_category",products_by_category)
    score = eval_response_with_ideal(response,ideal,debug=False)
    print(f"{i}: {score}")
    score_accum += score
    

n_examples = len(msg_ideal_pairs_set)
fraction_correct = score_accum / n_examples
print(f"Fraction correct out of {n_examples}: {fraction_correct}")
```


---

