在這段影片中，我們將學習如何透過串接多個提示（prompts），將複雜任務拆解為一連串較簡單的子任務。你可能會好奇，為什麼要將一個任務拆成多個提示來完成，而不是像我們在上一部影片中學到的，使用單一提示和連鎖思維（chain-of-thought）推理一次完成？

我們已經證明語言模型非常擅長理解複雜的指令，尤其是像 GPT-4 這樣的進階模型。

讓我透過兩個比喻來解釋為什麼我們會這麼做，以比較連鎖思維與多提示串接這兩種方式。

第一個比喻是將兩者相比：一次性地烹飪一頓複雜的大餐，與分階段進行烹飪。

使用一個長且複雜的指令，就像是一次完成整頓大餐——你得同時管理多種食材、烹飪技巧與時間，這樣會很難確保每個部分都完美烹調。而串接多個提示就像是分階段烹飪，你可以一次專注處理一個部分，確保每一項都正確完成，再進行下一步。

這種方法能夠拆解任務的複雜度，使其更容易管理，也降低出錯的可能性。

不過，這種方法對於非常簡單的任務來說可能就顯得多餘與過度設計了。

另一個稍微更貼切的比喻是：閱讀一段充滿混亂的「義大利麵式程式碼（spaghetti code）」與一個簡單的模組化程式。

造成義大利麵式程式碼難以除錯的原因是邏輯之間模糊不清且依賴關係複雜。這種情況也可能出現在使用語言模型處理複雜的一步驟任務時。當你可以維持每一步的系統狀態，並依據當下狀態採取不同行動時，串接提示就是一種非常強大的策略。

舉例來說，當你完成對某個客戶查詢的分類後，這個分類結果就是目前的狀態，例如這是一個帳戶問題或產品問題。

然後你就可以根據這個狀態採取不同的處理方式。

每一個子任務都只包含對應狀態所需的指令，這樣不僅讓系統更容易管理，也確保模型有足夠資訊執行任務，同時降低錯誤發生率。

這種方法也能降低成本，因為較長的提示會消耗更多 token，而 token 是按量計費的；而且在某些情況下，可能根本不需要列出所有步驟。

另一個優點是，更容易測試哪一個步驟發生錯誤，或者在人機協作的流程中加入人工審查的環節。

所以總結一下（因為剛才講了很多），與其在單一提示中使用數十個項目符號或好幾段文字來描述整個複雜的工作流程，不如在系統外部追蹤任務狀態，並在需要時注入相關的指令。

那麼，什麼樣的問題算是複雜問題呢？通常，如果一個任務包含很多不同的指令，並且任何一條指令都有可能套用在特定情況下，那它就屬於複雜任務。這種情況下，模型可能很難推理出該做什麼。而當你與這些模型互動得越多，你就越能培養出什麼時候該使用這種策略、什麼時候該使用前一種策略的直覺。

還有一個我尚未提到的額外好處是：這種方法也允許模型在工作流程的某個環節使用外部工具（如果有需要的話）。例如，模型可能會選擇查詢產品目錄、呼叫 API 或搜尋知識庫，這些都是無法僅靠單一提示完成的。

那麼接下來，我們來看一個實作範例。

我們將使用上一部影片的例子：回答使用者關於某個產品的問題，但這次會使用更多產品，並將流程拆解為多個提示。

我們會使用和前面影片中相同的分隔符號（例如四個井字號 ####）。

讓我們先來看看我們的系統訊息：

「你將會收到客服查詢，查詢內容會以四個井字號（####）作為分隔。請輸出一個 Python 的物件列表，每個物件格式如下：包含類別（Category，須為下列預設欄位之一）與產品（Products，必須來自下方允許的產品清單）。」

「類別與產品名稱必須存在於查詢文字中。如果有提到產品，該產品必須歸類至對應的類別。如果查詢中沒有任何符合的類別或產品，請回傳空的列表。」

然後我們定義了一份允許使用的產品清單，其中每個類別下有對應的產品名稱。

系統訊息的最後一段是：「請**僅輸出物件列表，不要包含其他內容**。」

接著，我們收到的使用者訊息是：「請告訴我關於 SmartX ProPhone 和 Fotosnap DSLR 相機的資訊。還有你們的電視。」

這個查詢提到了兩個具體產品，還有一個一般性產品類別（電視）。我們的系統應該要能根據此訊息，回傳對應的產品與類別列表。

我們會將系統訊息與使用者訊息格式化為訊息陣列（messages array），然後使用模型取得回應。

接著你會看到模型回傳的物件清單，裡面包含類別與對應產品。例如「Smartphones and Accessories」包含「SmartX ProPhone」，「Cameras and Photography」包含「Fotosnap DSLR Camera」，而「Televisions and Home Theater」則因為沒有指定特定產品，只列出了類別。

這種結構化的輸出讓我們能夠將其讀入 Python 清單中繼續處理，這非常實用。

下一個使用者訊息是：「我的路由器壞了。」你會注意到我們的產品清單中並沒有路由器，因此模型回傳空列表。

在完成分類步驟後，如果有找到產品或類別，我們就會將這些資訊載入提示中，幫助模型更好地回答問題。

在我們的流程中，這一步結束後的狀態是：有找到產品與類別，或是沒有找到。如果沒有，就不需要查詢其他資料。當然如果你要真正把這套流程建成系統，可能會使用更簡潔的類別名稱（例如 "computers_and_laptops"）以避免空白與特殊字元問題，不過現在的做法也可以運作。

接著我們要查詢使用者提到的產品資訊：像是那支手機、那台相機，以及所有的電視。我們需要一份產品目錄作為查詢依據。

這裡我們有一份假想的產品資訊，由 GPT-4 生成，包含產品名稱、類別、品牌、保固等欄位。我們用字典形式儲存，產品名稱為 key，詳細資料為 value。

我們接著定義幾個輔助函數來查詢資料，如 `get_product_by_name(name)` 與 `get_products_by_category(category)`。

這些函數會讓我們根據名稱或類別取出相關產品資訊。

然後，我們需要一個函數來將模型的字串輸出轉換成 Python 的 list，這裡會用到 JSON 的 `loads()` 函數，再加上一些錯誤處理。

首先，我們會檢查輸入字串是否為 `None`。

如果前面的步驟有任何失敗，我們就直接返回 `None`。

接下來，我們會使用 `try except` 區塊來確保捕捉到任何錯誤。

首先，我們會將輸入字串中的單引號替換為雙引號，確保我們可以正確地處理 JSON，然後使用 JSON 的 `loads` 函數將輸入字串讀取到陣列（或稱列表）中，然後返回這個列表。如果解碼出現錯誤，我們會打印錯誤訊息並返回 `None`。現在讓我們來試試看這個例子。

我們會使用 `read_string_to_list` 輔助函數來取得我們的類別和產品清單，並將它應用到模型的回應上，然後我們會打印這個清單。

結果應該是一樣的，讓我先運行一次。

如你所見，現在變數的類型變成了清單（list），而不是字串（string）。我們這樣做的目的就是將產品資訊轉換成一個清單，這樣我們就能將它加到下一個提示中，這個提示會讓模型回答使用者的問題。為了做到這點，我們需要將產品資訊放入一個清晰的字串格式，這樣我們可以將它加入到提示中。所以，我們也會創建一個輔助函數來處理這個。

我們會將這個輔助函數命名為 `generate_output_string`，它會接收我們剛才創建的資料清單，也就是這個清單。

接下來，我將貼上一些程式碼，並展示這個函數的例子，然後我們一起了解它在做什麼。

首先，我們會從使用者的第一則訊息中提取產品資訊，然後使用這個輔助函數 `generate_output_string` 處理我們的類別和產品清單，如果還記得的話，就是這個清單。

所以，這裡我們擁有所有在使用者訊息中提到的產品資訊。

我們有使用者提到的手機、相機，還有所有我們的電視產品資訊。

這些資訊對於模型回答使用者的初步問題將非常有幫助。

如果你對這個函數的運作方式感興趣，我會簡要介紹一下，但你也可以隨時暫停影片，仔細閱讀程式碼。

基本上，它會遍歷這個清單中的所有物件，首先檢查是否有產品資料。如果有，它會提取每個產品的資訊，然後檢查是否有類別資料（如果沒有產品）。例如，這個物件就會這樣處理，然後提取該類別中所有產品的資訊。接著它會把這些資訊加入到字串中，並返回這個字串。

到這裡為止，我們已經找到了解答使用者問題所需的相關產品資訊。現在是模型實際回答問題的時候了。

讓我們來看看系統訊息。這是我們的指示：

>「你是大型電子商店的客服助理。請以友善且有幫助的語氣回答，並且儘量保持簡潔明瞭。確保向使用者詢問相關的後續問題。」

我們希望這是一個互動式的體驗，讓使用者能夠參與其中。

作為提醒，這是我們的初始使用者訊息。我會再把它加回來。

現在我們要創建 `messages` 陣列。

這是我們要送給模型的輸入。讓我們來一步一步看這個過程：

- 第一則訊息是系統訊息，像平常一樣。
- 第二則是使用者的訊息。
- 第三則是我們的 assistant 訊息。

這則訊息包含了我們剛剛查找到的所有產品資訊。

這段訊息格式是：「相關產品資訊」換行，然後是我們找到的產品資訊。

現在，模型已經具備了回答使用者問題所需的上下文資訊。接著我們可以取得最終回應並將其打印出來。

我們希望模型能夠使用這些相關的產品資訊來回答使用者問題，並提供有幫助的答案。

首先，模型會介紹 SmartX ProPhone。

接著，會介紹 Fotosnap 相機，然後列出我們庫存中的各種電視，並詢問使用者一個後續問題。

正如你所見，透過將任務分解成一系列步驟，我們成功將與使用者查詢相關的資訊載入到上下文中，從而為模型提供了它需要的正確上下文，讓它有效地回答問題。

你可能會想，為什麼我們要選擇性地載入產品描述到提示中，而不是一次性把所有產品描述都包含進來，讓模型自己挑選需要的資訊？

其實有幾個原因：

首先，如果把所有產品描述都加進來，可能會讓上下文變得太混亂，就像一個人需要處理大量資訊時會感到困惑一樣。

不過，對於像 GPT-4 這樣的先進模型來說，這個問題就沒有那麼嚴重，特別是當上下文結構清晰，模型可以聰明地忽略那些顯然不相關的資訊。

但接下來的理由更有說服力：

1. **上下文限制**：語言模型有固定的輸入和輸出 token 數量限制。如果你的產品數量很大（例如一個龐大的產品目錄），你根本無法將所有描述放入上下文中。
   
2. **成本考量**：語言模型是按 token 收費的。如果把所有描述都塞進提示中，生成成本會大大增加。

所以，通過**選擇性載入資訊**，我們可以減少生成回應的成本。

總結來說，確定何時動態載入資訊到模型的上下文中，並讓模型決定何時需要更多資訊，是增強這些模型能力的一個重要方法。

再次強調，語言模型應該被視為一個**推理代理**，它需要適當的上下文來做出有用的結論並執行有意義的任務。

在這個例子中，我們提供了產品資訊，然後模型根據這些資訊推理出一個有用的回答。

在這個範例中，我們只呼叫了一些函數，像是根據產品名稱或類別名稱來獲取描述。

但其實模型能夠很好地決定何時使用各種不同的工具，並且能夠在指示下正確使用它們。這就是 **ChatGPT 插件** 的概念。

我們告訴模型它可以使用哪些工具，這些工具能做什麼，然後模型會根據需要選擇在需要的時候使用它們。

在我們的範例中，我們只能透過完全匹配的產品名稱或類別名稱來查找資料，但也有更多先進的資訊檢索技術。

其中一種最有效的方式就是使用 **文本嵌入（text embeddings）**。

透過嵌入，我們能夠在大量資料中高效地檢索相關資訊，找到與特定查詢相關的資料。

使用文本嵌入的主要優勢之一是它支持模糊搜尋或語意搜尋，這使得我們可以在不使用精確關鍵字的情況下，找到相關資料。

舉例來說，我們不一定需要知道產品的精確名稱，像「手機」這樣的一個更廣泛的查詢也能找到相關產品。

我們計畫很快推出一門完整的課程，介紹如何利用嵌入技術進行各種應用，敬請期待！

至此，我們進入下一個影片，我們將討論如何評估語言模型的輸出。
